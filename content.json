{"meta":{"title":"BLOOK","subtitle":"GP's blog and book","description":"javascript","author":"GP","url":"http://blook.me"},"pages":[{"title":"关于我","date":"2017-03-07T11:16:34.000Z","updated":"2018-03-05T03:16:29.178Z","comments":true,"path":"about/index.html","permalink":"http://blook.me/about/index.html","excerpt":"","text":"age: 29job: FEweChar: gp0320"}],"posts":[{"title":"计算机网络相关","slug":"计算机网络相关","date":"2018-03-29T05:03:50.000Z","updated":"2018-03-29T07:00:13.206Z","comments":true,"path":"2018/03/29/计算机网络相关/","link":"","permalink":"http://blook.me/2018/03/29/计算机网络相关/","excerpt":"计算机通信 是两个运行的进程之间的通信 网络边缘边通信分两种： 1、客户-服务器方式（c/s）(b/s 是一种特例)； 2、对等方式p2p (peer) OSI： open systems interconnection 开放系统互连基本参考模型 五层协议？","text":"计算机通信 是两个运行的进程之间的通信 网络边缘边通信分两种： 1、客户-服务器方式（c/s）(b/s 是一种特例)； 2、对等方式p2p (peer) OSI： open systems interconnection 开放系统互连基本参考模型 五层协议？ 注 五层协议的体系结构只为介绍网络原理而设计，实用应用的还是tcp/ip四层体系结构 应用层进程间的协议 数据单元称为报文 运输层传输控制协议TCP transmission control protocol 提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段用户数据报协议 UDP user datagram protocol 提供无连接的，尽最大努力的数据传输服务，不保证数据传输的可靠性，其数据传输的单位是 用户数据报 网络层IP协议 数据分组，2.要选择合适的路由，能够通过网络中的路由器找到目的主机。 数据链路层加上首部和尾部 组装成帧 物理层从首部传开始传 不再加首部 TCP/UDP区别 UDP在传送数据之前不需要先建立连接. 远地主机的运输层在收到 UDP 报文后, 不要给出任何确认. 虽然 UDP 不提供可靠交付. 但在某些情况下 UDP 却是一种最有效的工方式. TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要放连接. TCP 不提供广播或多插服务. 由于 TCP 要提供可靠的、 面向连接的运输眠务,此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等.这不仅使协议数据单元的首部增大很多.还要占用许多的处理机资源 socket - (IP 地址： 端口号）每一条TCP连接唯一地被通信两端的两个端点 (即两个套接宇) 所确定.即TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)} TCP怎么做到的可靠传输？ 停止等待协议 超时重传 HTTPS和HTTP的区别一、https协议需要到ca申请证书，一般免费证书很少，需要交费。二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。","categories":[{"name":"osi/TCP","slug":"osi-TCP","permalink":"http://blook.me/categories/osi-TCP/"}],"tags":[]},{"title":"css权重计算","slug":"css权重计算","date":"2018-03-27T03:28:41.000Z","updated":"2018-03-27T03:39:22.512Z","comments":true,"path":"2018/03/27/css权重计算/","link":"","permalink":"http://blook.me/2018/03/27/css权重计算/","excerpt":"","text":"选择器类型 1、ID #id 2、class .class 3、标签 p 4、通用 * 5、属性 [type=”text”] 6、伪类 ：hover 7、伪元素 ::first-line 8、子选择器、相邻选择器 权重计算规则 第一等：代表内联样式，如: style=””，权值为1000。 第二等：代表ID选择器，如：#content，权值为0100。 第三等：代表类，伪类和属性选择器，如.content，权值为0010。 第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。 通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。 继承的样式没有权值。 123456789101112131415161701. *&#123;&#125; ====》002. li&#123;&#125; ====》1(一个元素)03. li:first-line&#123;&#125; ====》2(一个元素，一个伪元素)04. ul li &#123;&#125; ====》2（两个元素）05. ul ol+li&#123;&#125; ====》3（三个元素）06. h1+ *[rel=up] &#123;&#125; ====》11（一个属性选择器，一个元素）07. ul ol li.red&#123;&#125; ====》13（一个类，三个元素）08. li.red.level&#123;&#125; ====》21（两个类，一个元素）09. style=&quot;&quot; ====》1000(一个行内样式)10. p &#123;&#125; ====》1（一个元素）11. div p &#123;&#125; ====》2（两个元素）12. .sith &#123;&#125; ====》10（一个类）13. div p.sith&#123;&#125; ====》12（一个类，两个元素）14. #sith&#123;&#125; ====》100（一个ID选择器）15. body #darkside .sith p &#123;&#125; ====》112(1+100+10+1,一个Id选择器，一个类，两个元素)","categories":[],"tags":[]},{"title":"angular实现列表逐条动画指令","slug":"angular实现列表逐条动画","date":"2018-03-05T02:36:08.000Z","updated":"2018-03-05T02:50:51.921Z","comments":true,"path":"2018/03/05/angular实现列表逐条动画/","link":"","permalink":"http://blook.me/2018/03/05/angular实现列表逐条动画/","excerpt":"效果演示","text":"效果演示 自定义指令代码123456789101112.directive(&apos;reanimate&apos;, ()=&gt;&#123; // 列表渐进动画 return &#123; restrict: &apos;A&apos;, scope: &#123; index: &apos;@&apos;, &#125;, link(scope, element) &#123; element.css(&#123;&apos;transition-delay&apos;:0.05 * scope.index+&apos;s&apos;&#125;) &#125; &#125;&#125;) 指令调用1tr.slide-right(ng-repeat=&apos;item in vm.saleList&apos; reanimate index=&apos;&#123;&#123;$index&#125;&#125;&apos;) slide-right说明 此class来自ng-animation.styl 贴出部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445 .slide-right easingTimingFunction() &amp;.ng-enter transform(translateX(60px)) transitionDuration(250ms) opacity 0&amp;.ng-enter-active transform(translateX(0)) opacity 1&amp;.ng-leave transform(translateX(0)) transitionDuration(250ms) opacity 1&amp;.ng-leave-active transform(translateX(60px)) opacity 0// Hide&amp;.ng-hide-add transform(translateX(0)) transitionDuration(250ms) opacity:1&amp;.ng-hide-add.ng-hide-add-active transform(translateX(60px)) opacity:0// Show&amp;.ng-hide-remove transform(translateX(60px)) transitionDuration(250ms) display:block!important opacity:0&amp;.ng-hide-remove.ng-hide-remove-active transform(translateX(0)) opacity:1","categories":[],"tags":[]},{"title":"网络电视.ts视频格式+ffmpeg用法","slug":"网络电视-ts视频格式网页播放","date":"2018-03-04T09:43:41.000Z","updated":"2018-03-05T09:42:23.501Z","comments":true,"path":"2018/03/04/网络电视-ts视频格式网页播放/","link":"","permalink":"http://blook.me/2018/03/04/网络电视-ts视频格式网页播放/","excerpt":"","text":"把本地的文件转成可供浏览器直接播放的视频格式用以下代码1ffmpeg -i 文件名 -acodec aac -vcodec libx264 -r 23 -f mp4 导出文件名","categories":[],"tags":[]},{"title":"Daily English","slug":"DailyEnglish","date":"2017-12-14T11:10:55.000Z","updated":"2018-03-29T05:05:23.873Z","comments":true,"path":"2017/12/14/DailyEnglish/","link":"","permalink":"http://blook.me/2017/12/14/DailyEnglish/","excerpt":"12.13【Daily English#About shopping】 Show window 橱窗Fitting room 试衣间Try on 穿上试试Wrap up 包起来Free of charge 不收费Check out 结帐On hold 预留Refund 退款Invoice 发票Receipt 收据Counter 柜台Small change 零钱Promotion Code 促销码BOGO 买一赠一BOGO 50% OFF 第二件半价Mix and match 混合搭配（以满足获得优惠的条件）Free shipping 包邮Price match 比价Return policy 退货","text":"12.13【Daily English#About shopping】 Show window 橱窗Fitting room 试衣间Try on 穿上试试Wrap up 包起来Free of charge 不收费Check out 结帐On hold 预留Refund 退款Invoice 发票Receipt 收据Counter 柜台Small change 零钱Promotion Code 促销码BOGO 买一赠一BOGO 50% OFF 第二件半价Mix and match 混合搭配（以满足获得优惠的条件）Free shipping 包邮Price match 比价Return policy 退货 【Daily English#Nov. 18th】Today let’s learn something about shopping! 11月28日-11月29日，就是传说中的“黑色星期五 Black Friday”，美国零售市场全年最大促销折扣季的代表日，也就是西方版的双十一。Coupon 优惠券Reservation ticket 预约券Flash sale 限时抢购Final sale 最终销售（不退不换）Clearance 清仓大甩卖In-store only 仅限实体店Out of stock 售罄Value sets 优惠套装Gift with purchase满额送小样Gift Card 礼品卡…To be continued…[机智] 只含一个单词的句子第三波~Gone! —— 跑了！Gorgeous! —— 美极了！Great! —— 太好了！Hey! —— 嘿！Hopefully! —— 希望如此！有希望的话…Horrible! —— 好可怕！Hot! —— 好辣！Hush! —— (肃静)嘘！Hurry! —— 快点！Incredible! —— 不可思议！Indeed? —— 真的？Liar! —— 你撒谎！Listen! —— 听着！Marverllous! —— 棒极了！Now! —— 现在就做！Pardon! —— 请再说一遍！Perfect! —— 很完美！Please! —— 拜托了！Present! —— 到(有)！(用于点名时)Probably! —— 很可能！ Have a nice day 【Aug. 11th】只含一个单词的句子第二波~Cheers! —— 干杯！Congratulations! —— 恭喜啊！Correct! —— 对的！Crazy! —— 疯了！Damn! —— 该死的！Deal! —— 一言为定！Definitely! —— 当然！Disgusting! —— 好恶心呀！Drat! —— 讨厌！Encore! —— 再来一次！Exactly! —— 完全正确！Fantastic! —— 妙极了！Farewell! —— 再见啦！Fifty-fifty! —— 对半分！Foul! —— 犯规了！Fresh! —— 好有型！帅！ 最简洁的表达方式：只含一个单词的句子！Absolutely！—— 绝对正确！Adorable! —— 可爱极了！Amazing! —— 太神了！Anytime! —— 随时吩咐！Almost! —— 差不多了！Awful! —— 好可怕呀！After you. —— 您先。About when? —— 大约何时？All set? —— 一切妥当？Allow me! —— 让我来！Behave! —— 放尊重点！Bingo! —— 中了！Boring! —— 真无聊！Bravo! —— 太棒了！Bullshit! —— 胡说！ 【July 28th】英文口头禅⚡1.You bet. 一点也没错。2.Kind of. 是有那么一点。3.That’s OK. 不用了。4.Go out on a limb. 冒险。5.Same here. 我也是。 It’s still up in the air. 不确定。6.Just checking. 只是随口问问。7.The thing is.重点是。 fix up/hook up 撮合某人。 1.photocopier=复印机2.printer=打印机3.fax=fax machine=传真机4.paper trimmer=裁纸器5.paper shredder=碎纸机Day21.wastebasket=废纸篓2.notebook=笔记本3.desk calendar=台历4.business card case=名片盒5.envelope=信封Day31.computer=电脑2.laptop=笔记本电脑3.laptop stand=笔记本电脑支架4.all-in-one desktop=一体机5.monitor=显示器6.computer case=机箱 【July 14th】About marriage💑💑💑propose/pop the question 求婚；matchmaker 红娘；engagement 订婚；fiance 未婚夫； fiancee 未婚妻；bride and bridegroom 新娘和新郎；best man 伴郎； best maid 伴娘；honeymoon 蜜月；我的手机 11:04:49【July 12nd】About marriage💑💑💑propose/pop the question 求婚；matchmaker 红娘；engagement 订婚；fiance 未婚夫； fiancee 未婚妻；bride and bridegroom 新娘和新郎；best man 伴郎； best maid 伴娘；honeymoon 蜜月；divorce 离婚；father-in-law 岳父；mother-in-law 岳母； 【Jun.30th 颜外有意】·yellow 黄色的 yellow belly[直译]黄色的肚子[颜外之意]胆小的人；卑怯的人；卑鄙的人。eg.Everybody knows he is a yellow belly,so nobody likes him.大家都知道他是个胆小鬼，所以没人喜欢他。 yellow back[直译]黄色的背[颜外之意]通俗廉价的小说eg.There were a lot of yellow backs in the 19th century.19世纪有许多廉价小说。 yellow alert[直译]黄色的警报[颜外之意]空袭的预备警报eg.People will be frightened if there is a yellow alert.响起空袭的预备警报时人们会感到害怕。 yellow pages[直译]黄色的书页[颜外之意]黄页（分类商业电话号码簿）eg.I see yellow pages every evening.我每晚看分类广告。 我的手机 11:05:30【Jun.27rd】颜外有意black 黑色的1．black letter day[直译]黑体印刷的日子（在西方一般喜庆的日子在日历上会用红色标明，普通的日子印的是黑色）[颜外之意]倒霉的一天；不吉利的日子；凶日。eg. Yesterday,a black day,he had a car accident. 昨天他真倒霉，遭遇了车祸。2.in black and white[直译]用白色和黑色[颜外之意]用书面的形式eg.I want this agreement in black and white.我需要这份书面的协定3.a black look[直译]一个黑色的表情[颜外之意]面带怒容；气愤的眼神。eg.Mr. Smith gave his son a black look when he heard his son hadn’t go to school.史密斯先生听闻儿子没去学校，生气的看了他一眼。4.a black coat[直译]一件黑色的外套[颜外之意]职员；领薪阶层(现通称为white collar)eg.Mr.Johnson is a black coat.强生先生是一名公司职员。 我的手机 11:05:57【Daily English# Jun.20th】It’s worth a try! 值得一试！Just wait and see! 等着瞧！Know what I mean? 明白我的意思吧？None of your business! 没你事！So far, so good! 还过得去！Speaking of the devil! 说曹操，曹操到！The walls have ears! 隔墙有耳！We better get going! 最好马上就走！What’s on your mind? 你在想什么？You are the boss! 你是老大！You asked for it! 你自讨苦吃！You have my word! 我保证！我的手机 11:06:09【Daily English*Jun. 16th】Give me a break! 饶了我吧！Great minds think alike! 英雄所见略同！I cross my heart! 我发誓是真的！I just made it! 我做到了！I’ll be right back! 我马上回来！I’ll check it out! 我去查查看！I’ll see to it! 我会留意的！I’m in a hurry! 我赶时间！If I were you…=if I were in your shoes如果我是你。It’s no big deal! 没什么大不了的！ 我的手机 11:06:21【Daily English·Jun. 13rd】 Are you kidding me? 跟我开玩笑啊？Back in a moment! 马上回来！Come to the point! 有话直说！Do I have to? 我一定要做吗？Don’t count on me! 别指望我！Don’t get me wrong! 你搞错了！Don’t give me that! 少来这套！Don’t let me down! 别让我失望！Don’t over do it! 别做过头了！Get a move on! 快点吧！ 我的手机 11:06:34(碎片时间学英语：共享单车 Jun.9th) 单车共享在中国很火爆。Bike-sharing is booming in China.*bike-sharing是一个合成名词，放在主语位置没问题，表示“共享单车”这种现象，booming是一个形容词，表示“兴旺的、繁荣的、大受欢迎的”作表语。 路上好多人都在骑共享单车。Many people are riding shared bikes in the street.*shared bikes指实体的“共享单车”，作为前面动词ride的宾语。 .用智能手机扫共享单车上的二维码解锁。Use your smartphone to scan the QR code on a shared bike to unlock it. 路上好多人都在骑共享单车。Many people are riding shared bikes in the street.","categories":[{"name":"英语","slug":"英语","permalink":"http://blook.me/categories/英语/"}],"tags":[{"name":"口语","slug":"口语","permalink":"http://blook.me/tags/口语/"}]},{"title":"tree打印树状目录结构","slug":"tree打印树状目录结构","date":"2017-07-27T03:47:12.000Z","updated":"2018-03-27T03:59:36.461Z","comments":true,"path":"2017/07/27/tree打印树状目录结构/","link":"","permalink":"http://blook.me/2017/07/27/tree打印树状目录结构/","excerpt":"常用命令12tree -I &quot;node_modules|dist|build&quot; -L 3 &gt; tree.mdtree &quot;src/&quot; -L 3 -o tree.md","text":"常用命令12tree -I &quot;node_modules|dist|build&quot; -L 3 &gt; tree.mdtree &quot;src/&quot; -L 3 -o tree.md 常用配置说明12345678910// 屏蔽多规则文件:通过|分割，同时加上&quot;&quot;-I &quot;node_modules|dist&quot;// 只是目录-d //第三方npm包node_modules//文件类型*.html","categories":[],"tags":[]},{"title":"vue2+vuex+axios+router初次分享","slug":"vue-vuex-axios-router初次分享","date":"2017-07-24T09:11:08.000Z","updated":"2018-03-04T09:45:05.997Z","comments":true,"path":"2017/07/24/vue-vuex-axios-router初次分享/","link":"","permalink":"http://blook.me/2017/07/24/vue-vuex-axios-router初次分享/","excerpt":"配置转发 文件路径：config/index.js123456789101112port: 4444, // 端口proxyTable: &#123; &apos;/dev&apos;:&#123; target: &apos;http://dev.api.pdb.com/http/&apos;, pathRewrite: &#123; &apos;^/dev&apos;: &apos;&apos; // &apos;dev&apos;转换成空字符串 &#125;, changeOrigin: true, // 代理转发 &#125; &#125; axios 发送 http 文件路径：main.js 引用，依赖 123import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios, axios) 全局配置，请求headers 1234Vue.axios.defaults.baseURL = &apos;/dev&apos;Vue.axios.defaults.headers.common[&apos;X-Auth-Token&apos;] = Vue.localStorage.get(&apos;token&apos;)Vue.axios.defaults.headers.common[&apos;X-Auth-Advertiser&apos;] = &apos;-1&apos;Vue.axios.defaults.headers.common[&apos;content-type&apos;] = &apos;application/x-www-form-urlencoded; charset=UTF-8&apos; 全局配置,拦截器 1234567//在发送请求之前做某事import Qs from &quot;querystring&quot;Vue.axios.interceptors.request.use(config=&gt;&#123; config.data = Qs.stringify(config.data) return config;&#125;) 123456789101112131415//在得到响应之后做某事Vue.axios.interceptors.response.use(response =&gt;&#123; // 全局判断 code 码为0 直接return 需要使用的数据data if(response.data.ret == 0) &#123; return response.data.data &#125; // 全局判断 code 码为1 跳到登录页 else if(response.data.ret == 1) &#123; window.location.href = response.data.data.url return Promise.reject(response.data.msg) &#125; else &#123; // 不为0，把 msg, reject 到 error 层 return Promise.reject(response.data.msg) &#125;&#125;)","text":"配置转发 文件路径：config/index.js123456789101112port: 4444, // 端口proxyTable: &#123; &apos;/dev&apos;:&#123; target: &apos;http://dev.api.pdb.com/http/&apos;, pathRewrite: &#123; &apos;^/dev&apos;: &apos;&apos; // &apos;dev&apos;转换成空字符串 &#125;, changeOrigin: true, // 代理转发 &#125; &#125; axios 发送 http 文件路径：main.js 引用，依赖 123import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios, axios) 全局配置，请求headers 1234Vue.axios.defaults.baseURL = &apos;/dev&apos;Vue.axios.defaults.headers.common[&apos;X-Auth-Token&apos;] = Vue.localStorage.get(&apos;token&apos;)Vue.axios.defaults.headers.common[&apos;X-Auth-Advertiser&apos;] = &apos;-1&apos;Vue.axios.defaults.headers.common[&apos;content-type&apos;] = &apos;application/x-www-form-urlencoded; charset=UTF-8&apos; 全局配置,拦截器 1234567//在发送请求之前做某事import Qs from &quot;querystring&quot;Vue.axios.interceptors.request.use(config=&gt;&#123; config.data = Qs.stringify(config.data) return config;&#125;) 123456789101112131415//在得到响应之后做某事Vue.axios.interceptors.response.use(response =&gt;&#123; // 全局判断 code 码为0 直接return 需要使用的数据data if(response.data.ret == 0) &#123; return response.data.data &#125; // 全局判断 code 码为1 跳到登录页 else if(response.data.ret == 1) &#123; window.location.href = response.data.data.url return Promise.reject(response.data.msg) &#125; else &#123; // 不为0，把 msg, reject 到 error 层 return Promise.reject(response.data.msg) &#125;&#125;) router 路由 文件路径：router/index.js 引用，依赖 123import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router) 全局配置，请求headers12345678910111213141516171819202122232425262728293031import campaign from &apos;./campaign.js&apos;import version from &apos;./version.js&apos;export default new Router(&#123;// 去掉#号 mode: &apos;history&apos;, routes: [ // &#123; path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;, // 重定向 &#123; path: &apos;/campaign&apos;, redirect: &apos;/campaign/search&apos; &#125;, // 登录页 &#123; path: &apos;/&apos;, name: &apos;login&apos;, component: Login, &#125;, // layout 功能页 &#123; path: &apos;&apos;, abstract: true, component: Layout, // 子路由 children: [campaign, version] &#125; ]&#125;) campaign.js12345678910111213141516// 懒加载const campaignSearch = r =&gt; require.ensure([], () =&gt; r(require(&apos;@/components/campaign/Search.vue&apos;)), )export default &#123; path: &apos;/campaign&apos;, name: &apos;campaign&apos;, component: &#123;template: `&lt;div&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;`&#125;, children: [ &#123; path: &apos;search&apos;, // 注意子路由前 不加 / name: &apos;search&apos;, component: campaignSearch, &#125; ]&#125; router-link12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to=&quot;&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;&quot;&gt;Register&lt;/router-link&gt; router-link 编程式1234567891011// 字符串router.push(&apos;home&apos;)// 对象router.push(&#123; path: &apos;home&apos; &#125;)// 命名的路由router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;) 路由信息对象的属性1234567891011121314151617181920212223$route.path类型: string字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。$route.params类型: Object一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。$route.query类型: Object一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。$route.hash类型: string当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 单文件组件 使用 jade + styl ，文件内容多 可以采用引入式 123456789101112&lt;template lang=&quot;jade&quot;&gt; .navigation(id=&quot;nav&quot;) .header-top-bottom ul.first-munu li(v-for=&quot;(item,$index) in menuList&quot; ) router-link(v-bind:to=&quot;item.router&quot; active-class=&quot;active&quot;) span &#123;&#123;item.name&#125;&#125;&lt;/template&gt;&lt;script src=&quot;./header-nav.js&quot;&gt;&lt;/script&gt;&lt;style lang=&quot;styl&quot; src=&quot;./header-nav.styl&quot; scoped&gt;&lt;/style&gt; 1scoped 局部样式 自定义全局组件 RmSelect 为例 123456789101112131415import mySelect from &apos;./Select.vue&apos;// 这里是重点const RmSelect = &#123; install(Vue)&#123; Vue.component(&apos;RmSelect&apos;,mySelect) &#125;&#125;// 导出组件export default RmSelectmain.js// 自定义全局组件import RmSelect from &apos;@/components/select&apos;Vue.use(RmSelect) Vuex state 数据 getter 特别像computed。有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： 1234567891011121314const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Mutations 更改 Vuex 的 store 中的状态的唯一方法 Action Action 提交的是 mutation，而不是直接变更状态。在 action 内部执行异步操作.1234567891011121314151617181920212223const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;)// Action 通过 store.dispatch 方法触发：store.dispatch(&apos;increment&apos;)// Mutations 通过 store.commit 方法触发：store.commit(&apos;increment&apos;) 1、 组件的 methods 里面的 function, 例：this.$store.dispatch(‘getList’） 发送到 Action2、Action 收到后 进行异步 http 请求，请求完成后 commit(‘getList’,res) 到 mutations3、 mutations 的function 的第一个参数是 state,1234567mutations = &#123; getList (state, res) &#123; state.list = res.list state.status = res.status &#125;&#125; 命名空间12345678910111213// 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的namespaced: true,// 在 modules 的内部不需要加 命名空间的前缀getters[&apos;isAdmin&apos;]dispatch(&apos;login&apos;)commit(&apos;login&apos;)// 在外部的组件需要像下面这样使用getters[&apos;account/isAdmin&apos;]dispatch(&apos;account/login&apos;)commit(&apos;account/login&apos;) end:mixins 没有讲到,后来知道用法 工作之余学了两周，第一次用vue做东西，实践了几个栏目，当时用的还是很全面。 还看了看vue的源码，监听数据变化的原理","categories":[],"tags":[]},{"title":"html2jade用法总结","slug":"html2jade用法总结","date":"2017-07-04T08:18:11.000Z","updated":"2018-03-04T09:45:05.995Z","comments":true,"path":"2017/07/04/html2jade用法总结/","link":"","permalink":"http://blook.me/2017/07/04/html2jade用法总结/","excerpt":"安装1npm install -g html2jade 参数说明 -d, –double - 为属性使用双引号 -o, –outdir - 输出生成的文件路径 -n, –nspaces - 缩进生成文件的空格数。默认为2个空格 –donotencode - 中文编码 –bodyless - 不包含 html + body 标签 –noattrcomma - 属性之间不要逗号分隔 –noemptypipe - omit lines with only pipe (‘|’) printable character 去掉|","text":"安装1npm install -g html2jade 参数说明 -d, –double - 为属性使用双引号 -o, –outdir - 输出生成的文件路径 -n, –nspaces - 缩进生成文件的空格数。默认为2个空格 –donotencode - 中文编码 –bodyless - 不包含 html + body 标签 –noattrcomma - 属性之间不要逗号分隔 –noemptypipe - omit lines with only pipe (‘|’) printable character 去掉| 中文编码 当我们使用 html2jade 转换含有中文的html时，若是在终端中转换只用加个参数 --donotencode 就好了。 用例 123456html2jade ./views/campGroup/campGroup-editor.tmpl.html --donotencode --bodyless --noattrcomma --noemptypipe -o ./src/app/console/campGroup/editor/ // 所有html文件 *.html","categories":[],"tags":[]},{"title":"JS style","slug":"JS-style","date":"2017-03-14T08:26:24.000Z","updated":"2017-03-14T08:31:20.000Z","comments":true,"path":"2017/03/14/JS-style/","link":"","permalink":"http://blook.me/2017/03/14/JS-style/","excerpt":"JavaScript Style Guide1.0 继承自airbnb的规范和angular最佳实践 TM组前端开发流程 工具函数库 ES6 angular最佳实践 常用工具函数和代码片段 js规范","text":"JavaScript Style Guide1.0 继承自airbnb的规范和angular最佳实践 TM组前端开发流程 工具函数库 ES6 angular最佳实践 常用工具函数和代码片段 js规范 开发流程 申请gitlab，RAP账号 dev分支用来开发调试，test分支测试 master分支禁止修改代码，只能从test分支merge 代码符合后面的规范 推进相关接口的RAP文档 工具函数库 angular-ui-bootstrap 常见组件库 angular-ui-router 路由 echarts 可视化图表 moment 日期处理 lodash 语言增强函数（部分） 后续考虑加入其它的 比如rxjs等 ES6简介 模块化机制 import 解构赋值 Promise class语法糖 箭头函数 …arg代替apply和arguments let const ::obj.method ≡ bind 模板字符串 angular1.5使用规范 多用1.5的component，标签式组件都用component 属性增强型组件才选择directive 数据转换统一用filter 多用service，解放controller ui-router+component，路由即组件 controller,service,directive,filter,component的 写法示例 angular1.5+ES6最佳时间利用语言自己的特性，淡化和angular的耦合 模块机制 service controller component filter 功能复杂拆分的方式 模块 一个相对完整的功能，对外暴露moduleName方便module之间相互引入 12345//a.jsimport Factory from &apos;./Factory&apos;export angular.module(&quot;app-moduleA&quot;, []) .factory(&quot;FactoryA&quot;, FactoryA) .name; 1234//b.jsimport ModuleA from &apos;./a&apos;angular.module(&apos;app-init&apos;,[ModuleA]); factory12345678910111213// factory// a.jsexport default function FactoryA &#123; return &#123; a: 1 &#125;;&#125;// b.jsimport FactoryA from &apos;./a&apos;export angular.module(&quot;moduleA&quot;, []) .factory(&quot;FactoryA&quot;, FactoryA) .name; service123456789101112export default class Service &#123; getName() &#123; return &apos;kuitos&apos;; &#125;&#125;// b.jsimport Service from &apos;./Service&apos;;export default angular.module(&apos;services&apos;, []) .service(&apos;service&apos;, Service) .name; 依赖注入123456789export default class ControllerA &#123; constructor($http) &#123; &apos;ngInject&apos; this.$http = $http &#125; actionA()&#123; this.$http.get(...) &#125;&#125; 1234import ControllerA from &quot;./controllers/a&quot;export angular.module(&quot;moduleA&quot;, []) .controller(&quot;ControllerA&quot;, ControllerA) controller123456789export default class AppCtrl &#123; constructor() &#123; this.name = &apos;angular&amp;es6&apos; &#125; getName() &#123; return this.name &#125;&#125; component Controller123456789101112131415import template from &apos;./date-picker.tpl.html&apos;;import controller from &apos;./DatePickerCtrl&apos;;const ddo = &#123; template, controller, bindings: &#123; year: &apos;&lt;&apos;, month: &apos;&lt;&apos; &#125;&#125;;export default angular.module(&apos;components.datePicker&apos;, []) .component(&apos;datePicker&apos;, ddo) .name; 12345678910111213141516export default class DatePickerCtrl &#123; $onInit() &#123; this.year=&apos;2016&apos; this.month=&apos;12&apos; this.date = `$&#123;this.year&#125;-$&#123;this.month&#125;`; &#125; getMonth() &#123; ... &#125; getYear() &#123; ... &#125;&#125; 路由即组件1234567891011export default angular.module(&apos;app.project&apos;, [listComp]) .config(($stateProvider, $urlRouterProvider) =&gt; &#123; $stateProvider.state(&apos;project&apos;, &#123; parent: &apos;app&apos;, url: &apos;/project/:folderId&apos;, // controller和template都在组件内部维护 component: &apos;projectList&apos; &#125;) &#125;) .name 最终目的–淡化框架去除冗余，让代码易于维护 常见代码片段123456789101112131415//遍历数组[1, 2, 3].forEach(function(value, index) &#123; console.log(value);&#125;);//映射新数组arr = [1,2,3].map(v=&gt;v*2);// 所有元素是否通过测试[1,2,3,4].every(v=&gt;v&gt;3);//是否有元素通过测试[1,2,3,4].some(v=&gt;v&gt;3);//累加[1,2,3,4,5].reduce((pre,cur)=&gt;pre+cur); 123456789101112131415//过滤数组[1,2,3,4,5].filter(v=&gt;v&gt;3);[1,false,2,3].filter(v=&gt;v);//查找符合条件的元素;arr = [&#123;name:&apos;dasheng&apos;,age:18&#125;,&#123;name:&apos;rmos&apos;,age:1&#125;];arr.find(v=&gt;v.age&gt;10);// 查找索引arr.findIndex(v=&gt;v.age&gt;10);// 查找索引[1,2,3].indexOf(2);// 是否包含[1,2,3,4].includes(3);//数组字符串拼接[&apos;hello&apos;,&apos;world&apos;,&apos;addnewer&apos;].join(&apos;--&apos;); 123456789101112131415161718// 获取对象的keyObject.keys(&#123;name:&apos;rmos&apos;,age:1&#125;);// 获取对象里数据的数量Object.keys(&#123;name:&apos;rmos&apos;,age:1&#125;).length;// 遍历数组Object.entries(&#123;name:&apos;rmos&apos;,age:1&#125;);//[[&apos;name&apos;,&apos;rmos&apos;],[&apos;age&apos;,1]];Object.entries(&#123;name:&apos;rmos&apos;,age:1&#125;).forEach(([k,v])=&gt;&#123; console.log(v);&#125;)for(let o of dict)&#123;&#125; 123456789101112131415161718//去除空白&apos; hello world &apos;.trim();// 重复创建字符串&apos;hello&apos;.repeat(2);// 连接数组arr1=[1,2,3];arr2 = [4,5,6];arr1.concat(arr2);[...arr1,...ar2];// extend功能Object.assign(&#123;name:1,age:2&#125;,&#123;name:3&#125;);// 获取列表的头和尾const [head, ...tail] = [1, 2, 3];const [last, ...initial] = [1, 2, 3].reverse();// 数组去重arr = [1,2,3,4,3,2,1];[...new Set(arr)]; 12345678910111213141516//默认值function log(x=1,y=2)&#123;&#125;;function log(&#123;x,y=5&#125;);// 替代apply的参数args = [1,2,3];fn.apply(null,args);fn(...args);// bind apply ES7的规范，但是babel已经支持foo::bar === bar.bind(foo);args = [1,2];foo::bar(...args) === bar.apply(foo, args);// ::左边为空::obj.foo === obj::obj.foo ; javascript规范 校验工具eslint详细规则 强制要求jsdoc格式注释 ，参数和返回值 12345678910/** * Add two numbers. * @param &#123;number&#125; num1 The first number. * @param &#123;number&#125; num2 The second number. * @returns &#123;number&#125; The sum of the two numbers. */function add(num1, num2) &#123; return num1 + num2;&#125; 123456789101112131415161718192021/** * @param &#123;string&#125; name Whom to greet. */function greet(name) &#123; console.log(\"Hello \" + name);&#125;// class constructor allows missing @returns tag/** * Represents a sum. * @author shengxinjing */class Sum &#123; /** * @param &#123;number&#125; num1 The first number. * @param &#123;number&#125; num2 The second number. */ constructor(num1, num2) &#123; this.num1 = num1; this.num2 = num2; &#125;&#125; 全面使用ES6语法 禁止使用eval() 使用四个空格缩进 行尾需要加分号;,eslint: semi 用 const 定义常量; eslint: prefer-const, no-const-assign 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 如果对变量重新赋值, 用 let 替代 var. eslint: no-var 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; 对象 直接用字面量定义对象. eslint: no-new-object 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 动态给对象赋值，ES6的计算属性 123456789101112131415161718function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 对象方法使用简写. eslint: object-shorthand 1234567891011121314151617// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 对象属性简写，eslint: object-shorthand 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 对象简写写在前面 123456789101112131415161718const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; episodeOne: 1, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, episodeThree: 3, mayTheFourth: 4,&#125;; 合法的key不需要引号. eslint: quote-props 易读，并且易于压缩 12345678910111213// badconst bad = &#123; 'foo': 3, 'bar': 4, 'data-blah': 5,&#125;;// goodconst good = &#123; foo: 3, bar: 4, 'data-blah': 5,&#125;; 用 Object.assign 浅拷贝. 用展开符号... 去获取一个新的对象 1234567891011121314// very badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;); // this mutates `original` ಠ_ಠdelete copy.a; // so does this// badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;); // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;// goodconst original = &#123; a: 1, b: 2 &#125;;const copy = &#123; ...original, c: 3 &#125;; // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;const &#123; a, ...noA &#125; = copy; // noA =&gt; &#123; b: 2, c: 3 &#125; 数组 用字面量创建数组. eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; 用 ... to 复制数组. 123456789101112 // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i &lt; len; i += 1) &#123; itemsCopy[i] = items[i]; &#125;//bad const itemsCopy = angular.copy(items) // good const itemsCopy = [...items]; 用Array.from把类数组转换为数组 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 数组的回调函数，都要有return, eslint: array-callback-return 12345678// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map(x =&gt; x + 1); 解构 使用对象解构来获取对象的值 123456789101112131415// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 数组解构. 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 返回多个值的时候，用对象解构，不要用数组 因为返回值不需要考虑顺序 123456789101112131415// badfunction processInput(input) &#123; // then a miracle occurs return [left, right, top, bottom];&#125;// the caller needs to think about the order of return dataconst [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // then a miracle occurs return &#123; left, right, top, bottom &#125;;&#125;// the caller selects only the data they needconst &#123; left, top &#125; = processInput(input); 字符串 简单的字符串用单引号. eslint: quotes 12345678// badconst name = \"Capt. Janeway\";// bad - template literals should contain interpolation or newlinesconst name = `Capt. Janeway`;// goodconst name = 'Capt. Janeway'; 使用字符串模板连接字符串,可读性比较好 eslint: prefer-template template-curly-spacing 12345678910111213141516// badfunction sayHi(name) &#123; return 'How are you, ' + name + '?';&#125;// badfunction sayHi(name) &#123; return ['How are you, ', name, '?'].join();&#125;// badfunction sayHi(name) &#123; return `How are you, $&#123; name &#125;?`;&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; 禁止没有必要的转义，可读性差. eslint: no-useless-escape 123456// badconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';// goodconst foo = '\\'this\\' is \"quoted\"';const foo = `my name is '$&#123;name&#125;'`; 函数 不要在if，wihile里定义函数. eslint: no-loop-func Note: ECMA-262规定了 block 的语句. block作用域里不要定义函数 来源. 12345678910111213// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodlet test;if (currentUser) &#123; test = () =&gt; &#123; console.log('Yup.'); &#125;;&#125; 用...取代arguments. eslint: prefer-rest-params 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 用参数默认值来定义默认值 1234567891011121314151617// really badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 有默认值的参数放后面. 123456789// badfunction handleThings(opts = &#123;&#125;, name) &#123; // ...&#125;// goodfunction handleThings(name, opts = &#123;&#125;) &#123; // ...&#125; 函数定义要有空格 eslint: space-before-function-paren space-before-blocks 可读性 12345678// badconst f = function()&#123;&#125;;const g = function ()&#123;&#125;;const h = function() &#123;&#125;;// goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;; 调用函数的时候用 ... 展开参数数组去 eslint: prefer-spread 1234567891011// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 08, 05]));// goodnew Date(...[2016, 08, 05]); 箭头函数 多用箭头函数=&gt;（参数，匿名函数…）. eslint: prefer-arrow-callback, arrow-spacing 1234567891011// bad[1, 2, 3].map(function (x) &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); 如果函数只有一行，使用箭头函数简写形式，eslint: arrow-parens, arrow-body-style 1234567891011// bad[1, 2, 3].map(number =&gt; &#123; const nextNumber = number + 1; `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`);// good[1, 2, 3].map((number, index) =&gt; (&#123; [index]: number&#125;)); 如果箭头函数只有一个参数并且只有一行，不需要括号，否则都需要括号.eslint: arrow-parens 123456789101112131415161718// bad[1, 2, 3].map((x) =&gt; x * x);// good[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map(number =&gt; ( `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`));// bad[1, 2, 3].map(x =&gt; &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); Classes &amp; Constructors 用 class取代 prototype 123456789101112131415161718// badfunction Queue(contents = []) &#123; this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123; const value = this.queue[0]; return value;&#125;;// goodclass Queue &#123; constructor(contents = []) &#123; this.queue = [...contents]; &#125; pop() &#123; const value = this.queue[0]; return value; &#125;&#125; 用 extends 来继承 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 方法可以返回 this支持链式调用 pt123456789101112131415// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); 去除没有必要的constructor. eslint: no-useless-constructor- 1234567// badclass Jedi &#123; constructor() &#123;&#125; getName() &#123; return this.name; &#125;&#125; 避免重复的方法. eslint: no-dupe-class-members 123456789// badclass Foo &#123; bar() &#123; return 1; &#125; bar() &#123; return 2; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 1; &#125;&#125; 模块 不要import *. 1234// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 一个地址只import一次.eslint: no-duplicate-imports 1234567891011// badimport foo from 'foo';// … some other imports … //import &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2,&#125; from 'foo'; export变量，一定要const.防止被外部修改eslint: import/no-mutable-exports 1234567// badlet foo = 3;export &#123; foo &#125;// goodconst foo = 3;export &#123; foo &#125; 只export一个的话，用default.eslint: import/prefer-default-export 12345// badexport function foo() &#123;&#125;// goodexport default function foo() &#123;&#125; 所有的import写在前面.eslint: import/first Why? Since imports are hoisted, keeping them all at the top prevents surprising behavior. 1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); 迭代器和生成器 暂时不要用generators.还没有完美编译到ES5 用自带的迭代函数取代 for-in eslint: no-iterator no-restricted-syntax 用 map() / every() / filter() / find() / findIndex() / reduce() / some() / … 数组, 用 Object.keys() / Object.values() / Object.entries() 生成数组去处理对象 - 12345678910111213141516const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &#123; sum += num;&#125;sum === 15;// goodlet sum = 0;numbers.forEach(num =&gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; 属性 用小数点获取属性. eslint: dot-notation 12345678910const luke = &#123; jedi: true, age: 28,&#125;;// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 用 [] 获取动态属性的值 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp('jedi'); 变量 多用const定义变量. eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 用一个 const 定义一个变量. eslint: one-var jscs: disallowMultipleVarDecl 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 把 consts 和 let都放在一起,const在前面. 12345678910111213141516// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 不要链式赋值，会搞出全局变量 123456789101112131415161718// bad(function example() &#123; // JavaScript interprets this as // let a = ( b = ( c = 1 ) ); let a = b = c = 1;&#125;());console.log(a); // undefinedconsole.log(b); // 1console.log(c); // 1// good(function example() &#123; let a = 1; let b = a; let c = a;&#125;());console.log(a); // undefinedconsole.log(b); // undefinedconsole.log(c); // undefined 不要使用 (++, –)，代码费解，用’+=’之类的取代. eslint no-plusplus 123456789101112131415// badlet array = [1, 2, 3];let num = 1;num++;--num;// goodlet array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length; if里布尔值直接用，数字和字符串要显示写 123456789101112131415161718// badif (isValid === true) &#123;&#125;// goodif (isValid) &#123;&#125;// bad name is empty stringif (name) &#123;&#125;// goodif (name !== '') &#123;&#125;// badif (collection.length) &#123;&#125;// goodif (collection.length &gt; 0) &#123;&#125; 不要写复合三元表达式.代码费解，eslint rules: no-nested-ternary. 12345678910111213141516// badconst foo = maybe1 &gt; maybe2 ? \"bar\" : value1 &gt; value2 ? \"baz\" : null;// betterconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;// bestconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull; 去除不必要的三元表达式 ，eslint rules: no-unneeded-ternary. 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; 块 块代码都需要大括号 12345678910111213141516// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction foo() &#123; return false; &#125;// goodfunction bar() &#123; return false;&#125; else不要换行 . eslint: brace-style 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; 注释 Use /** ... */ for multi-line comments. 12345678910111213// bad// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123;&#125;// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) &#123;&#125; 用//单行注释，在代码前 123456789101112131415161718// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// goodfunction getType() &#123; // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125; 注释以空格开头. eslint: spaced-comment 1234567// bad//is current tabconst active = true;// good// is current tabconst active = true; 空格符 四个空格缩进. eslint: indent 123456789// badfunction bar() &#123;∙const name;&#125;// goodfunction baz() &#123;∙∙∙∙const name;&#125; 大括号等块级代码前面一个空格 eslint: space-before-blocks 12345678910111213141516// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year'&#125;);// gooddog.set('attr', &#123; age: '1 year'&#125;); if,while后面加空格，但是function不加 eslint: keyword-spacing 12345678910111213141516// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 赋值的=前后要有空格. eslint: space-infix-ops 12345// badconst x=y+5;// goodconst x = y + 5; 链式调用换行+缩进. eslint: newline-per-chained-call no-whitespace-before-property 12345678910// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount(); 块代码内部不要加空行. eslint: padded-blocks jscs: disallowPaddingNewlinesInBlocks 12345678910111213141516// badfunction bar() &#123; console.log(foo);&#125;// goodfunction bar() &#123; console.log(foo);&#125;// goodif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125; 每行代码不要超过100个字符 eslint: max-len 12345678910// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// bad$.ajax(&#123; method: 'POST', url: 'https://airbnb.com/', data: &#123; name: 'John' &#125; &#125;).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));// goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar 命名规范 避免一个字符的变量 eslint: id-length 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 采用驼峰命名对象，函数. eslint: camelcase 12345678// badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125;// goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 常量用大写字母加下划线 1DAY_IN_WEEK = 7 用大驼峰命名class eslint: new-cap 1234567891011 // bad function user(options) &#123; this.name = options.name; &#125; // good class User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125; 变量不要用-和_. eslint: no-underscore-dangle 显式类型转换 12345678910//badconst totalScore = this.reviewScore + &apos;&apos;;// goodconst totalScore = String(this.reviewScore);//bad inputValue=&apos;4&apos;const val = +inputValue;//goodconst val = Number(inputValue)//goodconst hasAge = !!age;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-03-02T10:10:53.000Z","updated":"2017-03-02T10:10:53.000Z","comments":true,"path":"2017/03/02/hello-world/","link":"","permalink":"http://blook.me/2017/03/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}