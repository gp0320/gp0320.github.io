{"meta":{"title":"BLOOK","subtitle":"GP's blog and book","description":"javascript","author":"GP","url":"http://blook.me"},"pages":[{"title":"关于我","date":"2017-03-07T11:16:34.000Z","updated":"2017-03-07T11:17:50.000Z","comments":true,"path":"about/index.html","permalink":"http://blook.me/about/index.html","excerpt":"","text":"higp"}],"posts":[{"title":"网络电视.ts视频格式+ffmpeg用法","slug":"网络电视-ts视频格式网页播放","date":"2018-03-04T09:43:41.000Z","updated":"2018-03-04T10:20:14.230Z","comments":true,"path":"2018/03/04/网络电视-ts视频格式网页播放/","link":"","permalink":"http://blook.me/2018/03/04/网络电视-ts视频格式网页播放/","excerpt":"","text":"把本地的文件转成可供浏览器直接播放的视频格式用以下代码1ffmpeg -i 文件名 -acodec aac -vcodec libx264 -r 23 -f mp4 导出文件名","categories":[],"tags":[]},{"title":"vue2+vuex+axios+router初次分享","slug":"vue-vuex-axios-router初次分享","date":"2017-07-24T09:11:08.000Z","updated":"2018-03-04T09:45:05.997Z","comments":true,"path":"2017/07/24/vue-vuex-axios-router初次分享/","link":"","permalink":"http://blook.me/2017/07/24/vue-vuex-axios-router初次分享/","excerpt":"配置转发 文件路径：config/index.js123456789101112port: 4444, // 端口proxyTable: &#123; &apos;/dev&apos;:&#123; target: &apos;http://dev.api.pdb.com/http/&apos;, pathRewrite: &#123; &apos;^/dev&apos;: &apos;&apos; // &apos;dev&apos;转换成空字符串 &#125;, changeOrigin: true, // 代理转发 &#125; &#125; axios 发送 http 文件路径：main.js 引用，依赖 123import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios, axios) 全局配置，请求headers 1234Vue.axios.defaults.baseURL = &apos;/dev&apos;Vue.axios.defaults.headers.common[&apos;X-Auth-Token&apos;] = Vue.localStorage.get(&apos;token&apos;)Vue.axios.defaults.headers.common[&apos;X-Auth-Advertiser&apos;] = &apos;-1&apos;Vue.axios.defaults.headers.common[&apos;content-type&apos;] = &apos;application/x-www-form-urlencoded; charset=UTF-8&apos; 全局配置,拦截器 1234567//在发送请求之前做某事import Qs from &quot;querystring&quot;Vue.axios.interceptors.request.use(config=&gt;&#123; config.data = Qs.stringify(config.data) return config;&#125;) 123456789101112131415//在得到响应之后做某事Vue.axios.interceptors.response.use(response =&gt;&#123; // 全局判断 code 码为0 直接return 需要使用的数据data if(response.data.ret == 0) &#123; return response.data.data &#125; // 全局判断 code 码为1 跳到登录页 else if(response.data.ret == 1) &#123; window.location.href = response.data.data.url return Promise.reject(response.data.msg) &#125; else &#123; // 不为0，把 msg, reject 到 error 层 return Promise.reject(response.data.msg) &#125;&#125;)","text":"配置转发 文件路径：config/index.js123456789101112port: 4444, // 端口proxyTable: &#123; &apos;/dev&apos;:&#123; target: &apos;http://dev.api.pdb.com/http/&apos;, pathRewrite: &#123; &apos;^/dev&apos;: &apos;&apos; // &apos;dev&apos;转换成空字符串 &#125;, changeOrigin: true, // 代理转发 &#125; &#125; axios 发送 http 文件路径：main.js 引用，依赖 123import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios, axios) 全局配置，请求headers 1234Vue.axios.defaults.baseURL = &apos;/dev&apos;Vue.axios.defaults.headers.common[&apos;X-Auth-Token&apos;] = Vue.localStorage.get(&apos;token&apos;)Vue.axios.defaults.headers.common[&apos;X-Auth-Advertiser&apos;] = &apos;-1&apos;Vue.axios.defaults.headers.common[&apos;content-type&apos;] = &apos;application/x-www-form-urlencoded; charset=UTF-8&apos; 全局配置,拦截器 1234567//在发送请求之前做某事import Qs from &quot;querystring&quot;Vue.axios.interceptors.request.use(config=&gt;&#123; config.data = Qs.stringify(config.data) return config;&#125;) 123456789101112131415//在得到响应之后做某事Vue.axios.interceptors.response.use(response =&gt;&#123; // 全局判断 code 码为0 直接return 需要使用的数据data if(response.data.ret == 0) &#123; return response.data.data &#125; // 全局判断 code 码为1 跳到登录页 else if(response.data.ret == 1) &#123; window.location.href = response.data.data.url return Promise.reject(response.data.msg) &#125; else &#123; // 不为0，把 msg, reject 到 error 层 return Promise.reject(response.data.msg) &#125;&#125;) router 路由 文件路径：router/index.js 引用，依赖 123import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router) 全局配置，请求headers12345678910111213141516171819202122232425262728293031import campaign from &apos;./campaign.js&apos;import version from &apos;./version.js&apos;export default new Router(&#123;// 去掉#号 mode: &apos;history&apos;, routes: [ // &#123; path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;, // 重定向 &#123; path: &apos;/campaign&apos;, redirect: &apos;/campaign/search&apos; &#125;, // 登录页 &#123; path: &apos;/&apos;, name: &apos;login&apos;, component: Login, &#125;, // layout 功能页 &#123; path: &apos;&apos;, abstract: true, component: Layout, // 子路由 children: [campaign, version] &#125; ]&#125;) campaign.js12345678910111213141516// 懒加载const campaignSearch = r =&gt; require.ensure([], () =&gt; r(require(&apos;@/components/campaign/Search.vue&apos;)), )export default &#123; path: &apos;/campaign&apos;, name: &apos;campaign&apos;, component: &#123;template: `&lt;div&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;`&#125;, children: [ &#123; path: &apos;search&apos;, // 注意子路由前 不加 / name: &apos;search&apos;, component: campaignSearch, &#125; ]&#125; router-link12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to=&quot;&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;&quot;&gt;Register&lt;/router-link&gt; router-link 编程式1234567891011// 字符串router.push(&apos;home&apos;)// 对象router.push(&#123; path: &apos;home&apos; &#125;)// 命名的路由router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;) 路由信息对象的属性1234567891011121314151617181920212223$route.path类型: string字符串，对应当前路由的路径，总是解析为绝对路径，如 &quot;/foo/bar&quot;。$route.params类型: Object一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。$route.query类型: Object一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。$route.hash类型: string当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 单文件组件 使用 jade + styl ，文件内容多 可以采用引入式 123456789101112&lt;template lang=&quot;jade&quot;&gt; .navigation(id=&quot;nav&quot;) .header-top-bottom ul.first-munu li(v-for=&quot;(item,$index) in menuList&quot; ) router-link(v-bind:to=&quot;item.router&quot; active-class=&quot;active&quot;) span &#123;&#123;item.name&#125;&#125;&lt;/template&gt;&lt;script src=&quot;./header-nav.js&quot;&gt;&lt;/script&gt;&lt;style lang=&quot;styl&quot; src=&quot;./header-nav.styl&quot; scoped&gt;&lt;/style&gt; 1scoped 局部样式 自定义全局组件 RmSelect 为例 123456789101112131415import mySelect from &apos;./Select.vue&apos;// 这里是重点const RmSelect = &#123; install(Vue)&#123; Vue.component(&apos;RmSelect&apos;,mySelect) &#125;&#125;// 导出组件export default RmSelectmain.js// 自定义全局组件import RmSelect from &apos;@/components/select&apos;Vue.use(RmSelect) Vuex state 数据 getter 特别像computed。有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： 1234567891011121314const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Mutations 更改 Vuex 的 store 中的状态的唯一方法 Action Action 提交的是 mutation，而不是直接变更状态。在 action 内部执行异步操作.1234567891011121314151617181920212223const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;)// Action 通过 store.dispatch 方法触发：store.dispatch(&apos;increment&apos;)// Mutations 通过 store.commit 方法触发：store.commit(&apos;increment&apos;) 1、 组件的 methods 里面的 function, 例：this.$store.dispatch(‘getList’） 发送到 Action2、Action 收到后 进行异步 http 请求，请求完成后 commit(‘getList’,res) 到 mutations3、 mutations 的function 的第一个参数是 state,1234567mutations = &#123; getList (state, res) &#123; state.list = res.list state.status = res.status &#125;&#125; 命名空间12345678910111213// 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的namespaced: true,// 在 modules 的内部不需要加 命名空间的前缀getters[&apos;isAdmin&apos;]dispatch(&apos;login&apos;)commit(&apos;login&apos;)// 在外部的组件需要像下面这样使用getters[&apos;account/isAdmin&apos;]dispatch(&apos;account/login&apos;)commit(&apos;account/login&apos;) end:mixins 没有讲到,后来知道用法 工作之余学了两周，第一次用vue做东西，实践了几个栏目，当时用的还是很全面。 还看了看vue的源码，监听数据变化的原理","categories":[],"tags":[]},{"title":"html2jade用法总结","slug":"html2jade用法总结","date":"2017-07-04T08:18:11.000Z","updated":"2018-03-04T09:45:05.995Z","comments":true,"path":"2017/07/04/html2jade用法总结/","link":"","permalink":"http://blook.me/2017/07/04/html2jade用法总结/","excerpt":"安装1npm install -g html2jade 参数说明 -d, –double - 为属性使用双引号 -o, –outdir - 输出生成的文件路径 -n, –nspaces - 缩进生成文件的空格数。默认为2个空格 –donotencode - 中文编码 –bodyless - 不包含 html + body 标签 –noattrcomma - 属性之间不要逗号分隔 –noemptypipe - omit lines with only pipe (‘|’) printable character 去掉|","text":"安装1npm install -g html2jade 参数说明 -d, –double - 为属性使用双引号 -o, –outdir - 输出生成的文件路径 -n, –nspaces - 缩进生成文件的空格数。默认为2个空格 –donotencode - 中文编码 –bodyless - 不包含 html + body 标签 –noattrcomma - 属性之间不要逗号分隔 –noemptypipe - omit lines with only pipe (‘|’) printable character 去掉| 中文编码 当我们使用 html2jade 转换含有中文的html时，若是在终端中转换只用加个参数 --donotencode 就好了。 用例 123456html2jade ./views/campGroup/campGroup-editor.tmpl.html --donotencode --bodyless --noattrcomma --noemptypipe -o ./src/app/console/campGroup/editor/ // 所有html文件 *.html","categories":[],"tags":[]},{"title":"add music","slug":"add-music","date":"2017-03-14T09:48:45.000Z","updated":"2017-03-14T09:48:57.000Z","comments":true,"path":"2017/03/14/add-music/","link":"","permalink":"http://blook.me/2017/03/14/add-music/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JS style","slug":"JS-style","date":"2017-03-14T08:26:24.000Z","updated":"2017-03-14T08:31:20.000Z","comments":true,"path":"2017/03/14/JS-style/","link":"","permalink":"http://blook.me/2017/03/14/JS-style/","excerpt":"JavaScript Style Guide1.0 继承自airbnb的规范和angular最佳实践 TM组前端开发流程 工具函数库 ES6 angular最佳实践 常用工具函数和代码片段 js规范","text":"JavaScript Style Guide1.0 继承自airbnb的规范和angular最佳实践 TM组前端开发流程 工具函数库 ES6 angular最佳实践 常用工具函数和代码片段 js规范 开发流程 申请gitlab，RAP账号 dev分支用来开发调试，test分支测试 master分支禁止修改代码，只能从test分支merge 代码符合后面的规范 推进相关接口的RAP文档 工具函数库 angular-ui-bootstrap 常见组件库 angular-ui-router 路由 echarts 可视化图表 moment 日期处理 lodash 语言增强函数（部分） 后续考虑加入其它的 比如rxjs等 ES6简介 模块化机制 import 解构赋值 Promise class语法糖 箭头函数 …arg代替apply和arguments let const ::obj.method ≡ bind 模板字符串 angular1.5使用规范 多用1.5的component，标签式组件都用component 属性增强型组件才选择directive 数据转换统一用filter 多用service，解放controller ui-router+component，路由即组件 controller,service,directive,filter,component的 写法示例 angular1.5+ES6最佳时间利用语言自己的特性，淡化和angular的耦合 模块机制 service controller component filter 功能复杂拆分的方式 模块 一个相对完整的功能，对外暴露moduleName方便module之间相互引入 12345//a.jsimport Factory from &apos;./Factory&apos;export angular.module(&quot;app-moduleA&quot;, []) .factory(&quot;FactoryA&quot;, FactoryA) .name; 1234//b.jsimport ModuleA from &apos;./a&apos;angular.module(&apos;app-init&apos;,[ModuleA]); factory12345678910111213// factory// a.jsexport default function FactoryA &#123; return &#123; a: 1 &#125;;&#125;// b.jsimport FactoryA from &apos;./a&apos;export angular.module(&quot;moduleA&quot;, []) .factory(&quot;FactoryA&quot;, FactoryA) .name; service123456789101112export default class Service &#123; getName() &#123; return &apos;kuitos&apos;; &#125;&#125;// b.jsimport Service from &apos;./Service&apos;;export default angular.module(&apos;services&apos;, []) .service(&apos;service&apos;, Service) .name; 依赖注入123456789export default class ControllerA &#123; constructor($http) &#123; &apos;ngInject&apos; this.$http = $http &#125; actionA()&#123; this.$http.get(...) &#125;&#125; 1234import ControllerA from &quot;./controllers/a&quot;export angular.module(&quot;moduleA&quot;, []) .controller(&quot;ControllerA&quot;, ControllerA) controller123456789export default class AppCtrl &#123; constructor() &#123; this.name = &apos;angular&amp;es6&apos; &#125; getName() &#123; return this.name &#125;&#125; component Controller123456789101112131415import template from &apos;./date-picker.tpl.html&apos;;import controller from &apos;./DatePickerCtrl&apos;;const ddo = &#123; template, controller, bindings: &#123; year: &apos;&lt;&apos;, month: &apos;&lt;&apos; &#125;&#125;;export default angular.module(&apos;components.datePicker&apos;, []) .component(&apos;datePicker&apos;, ddo) .name; 12345678910111213141516export default class DatePickerCtrl &#123; $onInit() &#123; this.year=&apos;2016&apos; this.month=&apos;12&apos; this.date = `$&#123;this.year&#125;-$&#123;this.month&#125;`; &#125; getMonth() &#123; ... &#125; getYear() &#123; ... &#125;&#125; 路由即组件1234567891011export default angular.module(&apos;app.project&apos;, [listComp]) .config(($stateProvider, $urlRouterProvider) =&gt; &#123; $stateProvider.state(&apos;project&apos;, &#123; parent: &apos;app&apos;, url: &apos;/project/:folderId&apos;, // controller和template都在组件内部维护 component: &apos;projectList&apos; &#125;) &#125;) .name 最终目的–淡化框架去除冗余，让代码易于维护 常见代码片段123456789101112131415//遍历数组[1, 2, 3].forEach(function(value, index) &#123; console.log(value);&#125;);//映射新数组arr = [1,2,3].map(v=&gt;v*2);// 所有元素是否通过测试[1,2,3,4].every(v=&gt;v&gt;3);//是否有元素通过测试[1,2,3,4].some(v=&gt;v&gt;3);//累加[1,2,3,4,5].reduce((pre,cur)=&gt;pre+cur); 123456789101112131415//过滤数组[1,2,3,4,5].filter(v=&gt;v&gt;3);[1,false,2,3].filter(v=&gt;v);//查找符合条件的元素;arr = [&#123;name:&apos;dasheng&apos;,age:18&#125;,&#123;name:&apos;rmos&apos;,age:1&#125;];arr.find(v=&gt;v.age&gt;10);// 查找索引arr.findIndex(v=&gt;v.age&gt;10);// 查找索引[1,2,3].indexOf(2);// 是否包含[1,2,3,4].includes(3);//数组字符串拼接[&apos;hello&apos;,&apos;world&apos;,&apos;addnewer&apos;].join(&apos;--&apos;); 123456789101112131415161718// 获取对象的keyObject.keys(&#123;name:&apos;rmos&apos;,age:1&#125;);// 获取对象里数据的数量Object.keys(&#123;name:&apos;rmos&apos;,age:1&#125;).length;// 遍历数组Object.entries(&#123;name:&apos;rmos&apos;,age:1&#125;);//[[&apos;name&apos;,&apos;rmos&apos;],[&apos;age&apos;,1]];Object.entries(&#123;name:&apos;rmos&apos;,age:1&#125;).forEach(([k,v])=&gt;&#123; console.log(v);&#125;)for(let o of dict)&#123;&#125; 123456789101112131415161718//去除空白&apos; hello world &apos;.trim();// 重复创建字符串&apos;hello&apos;.repeat(2);// 连接数组arr1=[1,2,3];arr2 = [4,5,6];arr1.concat(arr2);[...arr1,...ar2];// extend功能Object.assign(&#123;name:1,age:2&#125;,&#123;name:3&#125;);// 获取列表的头和尾const [head, ...tail] = [1, 2, 3];const [last, ...initial] = [1, 2, 3].reverse();// 数组去重arr = [1,2,3,4,3,2,1];[...new Set(arr)]; 12345678910111213141516//默认值function log(x=1,y=2)&#123;&#125;;function log(&#123;x,y=5&#125;);// 替代apply的参数args = [1,2,3];fn.apply(null,args);fn(...args);// bind apply ES7的规范，但是babel已经支持foo::bar === bar.bind(foo);args = [1,2];foo::bar(...args) === bar.apply(foo, args);// ::左边为空::obj.foo === obj::obj.foo ; javascript规范 校验工具eslint详细规则 强制要求jsdoc格式注释 ，参数和返回值 12345678910/** * Add two numbers. * @param &#123;number&#125; num1 The first number. * @param &#123;number&#125; num2 The second number. * @returns &#123;number&#125; The sum of the two numbers. */function add(num1, num2) &#123; return num1 + num2;&#125; 123456789101112131415161718192021/** * @param &#123;string&#125; name Whom to greet. */function greet(name) &#123; console.log(\"Hello \" + name);&#125;// class constructor allows missing @returns tag/** * Represents a sum. * @author shengxinjing */class Sum &#123; /** * @param &#123;number&#125; num1 The first number. * @param &#123;number&#125; num2 The second number. */ constructor(num1, num2) &#123; this.num1 = num1; this.num2 = num2; &#125;&#125; 全面使用ES6语法 禁止使用eval() 使用四个空格缩进 行尾需要加分号;,eslint: semi 用 const 定义常量; eslint: prefer-const, no-const-assign 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 如果对变量重新赋值, 用 let 替代 var. eslint: no-var 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; 对象 直接用字面量定义对象. eslint: no-new-object 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 动态给对象赋值，ES6的计算属性 123456789101112131415161718function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; 对象方法使用简写. eslint: object-shorthand 1234567891011121314151617// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 对象属性简写，eslint: object-shorthand 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 对象简写写在前面 123456789101112131415161718const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; episodeOne: 1, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, episodeThree: 3, mayTheFourth: 4,&#125;; 合法的key不需要引号. eslint: quote-props 易读，并且易于压缩 12345678910111213// badconst bad = &#123; 'foo': 3, 'bar': 4, 'data-blah': 5,&#125;;// goodconst good = &#123; foo: 3, bar: 4, 'data-blah': 5,&#125;; 用 Object.assign 浅拷贝. 用展开符号... 去获取一个新的对象 1234567891011121314// very badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(original, &#123; c: 3 &#125;); // this mutates `original` ಠ_ಠdelete copy.a; // so does this// badconst original = &#123; a: 1, b: 2 &#125;;const copy = Object.assign(&#123;&#125;, original, &#123; c: 3 &#125;); // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;// goodconst original = &#123; a: 1, b: 2 &#125;;const copy = &#123; ...original, c: 3 &#125;; // copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;const &#123; a, ...noA &#125; = copy; // noA =&gt; &#123; b: 2, c: 3 &#125; 数组 用字面量创建数组. eslint: no-array-constructor 12345// badconst items = new Array();// goodconst items = []; 用 ... to 复制数组. 123456789101112 // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i &lt; len; i += 1) &#123; itemsCopy[i] = items[i]; &#125;//bad const itemsCopy = angular.copy(items) // good const itemsCopy = [...items]; 用Array.from把类数组转换为数组 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 数组的回调函数，都要有return, eslint: array-callback-return 12345678// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map(x =&gt; x + 1); 解构 使用对象解构来获取对象的值 123456789101112131415// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 数组解构. 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 返回多个值的时候，用对象解构，不要用数组 因为返回值不需要考虑顺序 123456789101112131415// badfunction processInput(input) &#123; // then a miracle occurs return [left, right, top, bottom];&#125;// the caller needs to think about the order of return dataconst [left, __, top] = processInput(input);// goodfunction processInput(input) &#123; // then a miracle occurs return &#123; left, right, top, bottom &#125;;&#125;// the caller selects only the data they needconst &#123; left, top &#125; = processInput(input); 字符串 简单的字符串用单引号. eslint: quotes 12345678// badconst name = \"Capt. Janeway\";// bad - template literals should contain interpolation or newlinesconst name = `Capt. Janeway`;// goodconst name = 'Capt. Janeway'; 使用字符串模板连接字符串,可读性比较好 eslint: prefer-template template-curly-spacing 12345678910111213141516// badfunction sayHi(name) &#123; return 'How are you, ' + name + '?';&#125;// badfunction sayHi(name) &#123; return ['How are you, ', name, '?'].join();&#125;// badfunction sayHi(name) &#123; return `How are you, $&#123; name &#125;?`;&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; 禁止没有必要的转义，可读性差. eslint: no-useless-escape 123456// badconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';// goodconst foo = '\\'this\\' is \"quoted\"';const foo = `my name is '$&#123;name&#125;'`; 函数 不要在if，wihile里定义函数. eslint: no-loop-func Note: ECMA-262规定了 block 的语句. block作用域里不要定义函数 来源. 12345678910111213// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodlet test;if (currentUser) &#123; test = () =&gt; &#123; console.log('Yup.'); &#125;;&#125; 用...取代arguments. eslint: prefer-rest-params 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join('');&#125;// goodfunction concatenateAll(...args) &#123; return args.join('');&#125; 用参数默认值来定义默认值 1234567891011121314151617// really badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 有默认值的参数放后面. 123456789// badfunction handleThings(opts = &#123;&#125;, name) &#123; // ...&#125;// goodfunction handleThings(name, opts = &#123;&#125;) &#123; // ...&#125; 函数定义要有空格 eslint: space-before-function-paren space-before-blocks 可读性 12345678// badconst f = function()&#123;&#125;;const g = function ()&#123;&#125;;const h = function() &#123;&#125;;// goodconst x = function () &#123;&#125;;const y = function a() &#123;&#125;; 调用函数的时候用 ... 展开参数数组去 eslint: prefer-spread 1234567891011// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 08, 05]));// goodnew Date(...[2016, 08, 05]); 箭头函数 多用箭头函数=&gt;（参数，匿名函数…）. eslint: prefer-arrow-callback, arrow-spacing 1234567891011// bad[1, 2, 3].map(function (x) &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); 如果函数只有一行，使用箭头函数简写形式，eslint: arrow-parens, arrow-body-style 1234567891011// bad[1, 2, 3].map(number =&gt; &#123; const nextNumber = number + 1; `A string containing the $&#123;nextNumber&#125;.`;&#125;);// good[1, 2, 3].map(number =&gt; `A string containing the $&#123;number&#125;.`);// good[1, 2, 3].map((number, index) =&gt; (&#123; [index]: number&#125;)); 如果箭头函数只有一个参数并且只有一行，不需要括号，否则都需要括号.eslint: arrow-parens 123456789101112131415161718// bad[1, 2, 3].map((x) =&gt; x * x);// good[1, 2, 3].map(x =&gt; x * x);// good[1, 2, 3].map(number =&gt; ( `A long string with the $&#123;number&#125;. It’s so long that we don’t want it to take up space on the .map line!`));// bad[1, 2, 3].map(x =&gt; &#123; const y = x + 1; return x * y;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; const y = x + 1; return x * y;&#125;); Classes &amp; Constructors 用 class取代 prototype 123456789101112131415161718// badfunction Queue(contents = []) &#123; this.queue = [...contents];&#125;Queue.prototype.pop = function () &#123; const value = this.queue[0]; return value;&#125;;// goodclass Queue &#123; constructor(contents = []) &#123; this.queue = [...contents]; &#125; pop() &#123; const value = this.queue[0]; return value; &#125;&#125; 用 extends 来继承 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function () &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 方法可以返回 this支持链式调用 pt123456789101112131415// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); 去除没有必要的constructor. eslint: no-useless-constructor- 1234567// badclass Jedi &#123; constructor() &#123;&#125; getName() &#123; return this.name; &#125;&#125; 避免重复的方法. eslint: no-dupe-class-members 123456789// badclass Foo &#123; bar() &#123; return 1; &#125; bar() &#123; return 2; &#125;&#125;// goodclass Foo &#123; bar() &#123; return 1; &#125;&#125; 模块 不要import *. 1234// badimport * as AirbnbStyleGuide from './AirbnbStyleGuide';// goodimport AirbnbStyleGuide from './AirbnbStyleGuide'; 一个地址只import一次.eslint: no-duplicate-imports 1234567891011// badimport foo from 'foo';// … some other imports … //import &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2 &#125; from 'foo';// goodimport foo, &#123; named1, named2,&#125; from 'foo'; export变量，一定要const.防止被外部修改eslint: import/no-mutable-exports 1234567// badlet foo = 3;export &#123; foo &#125;// goodconst foo = 3;export &#123; foo &#125; 只export一个的话，用default.eslint: import/prefer-default-export 12345// badexport function foo() &#123;&#125;// goodexport default function foo() &#123;&#125; 所有的import写在前面.eslint: import/first Why? Since imports are hoisted, keeping them all at the top prevents surprising behavior. 1234567891011// badimport foo from 'foo';foo.init();import bar from 'bar';// goodimport foo from 'foo';import bar from 'bar';foo.init(); 迭代器和生成器 暂时不要用generators.还没有完美编译到ES5 用自带的迭代函数取代 for-in eslint: no-iterator no-restricted-syntax 用 map() / every() / filter() / find() / findIndex() / reduce() / some() / … 数组, 用 Object.keys() / Object.values() / Object.entries() 生成数组去处理对象 - 12345678910111213141516const numbers = [1, 2, 3, 4, 5];// badlet sum = 0;for (let num of numbers) &#123; sum += num;&#125;sum === 15;// goodlet sum = 0;numbers.forEach(num =&gt; sum += num);sum === 15;// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0);sum === 15; 属性 用小数点获取属性. eslint: dot-notation 12345678910const luke = &#123; jedi: true, age: 28,&#125;;// badconst isJedi = luke['jedi'];// goodconst isJedi = luke.jedi; 用 [] 获取动态属性的值 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp('jedi'); 变量 多用const定义变量. eslint: no-undef prefer-const 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 用一个 const 定义一个变量. eslint: one-var jscs: disallowMultipleVarDecl 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = 'z';// goodconst items = getItems();const goSportsTeam = true;const dragonball = 'z'; 把 consts 和 let都放在一起,const在前面. 12345678910111213141516// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 不要链式赋值，会搞出全局变量 123456789101112131415161718// bad(function example() &#123; // JavaScript interprets this as // let a = ( b = ( c = 1 ) ); let a = b = c = 1;&#125;());console.log(a); // undefinedconsole.log(b); // 1console.log(c); // 1// good(function example() &#123; let a = 1; let b = a; let c = a;&#125;());console.log(a); // undefinedconsole.log(b); // undefinedconsole.log(c); // undefined 不要使用 (++, –)，代码费解，用’+=’之类的取代. eslint no-plusplus 123456789101112131415// badlet array = [1, 2, 3];let num = 1;num++;--num;// goodlet array = [1, 2, 3];let num = 1;num += 1;num -= 1;const sum = array.reduce((a, b) =&gt; a + b, 0);const truthyCount = array.filter(Boolean).length; if里布尔值直接用，数字和字符串要显示写 123456789101112131415161718// badif (isValid === true) &#123;&#125;// goodif (isValid) &#123;&#125;// bad name is empty stringif (name) &#123;&#125;// goodif (name !== '') &#123;&#125;// badif (collection.length) &#123;&#125;// goodif (collection.length &gt; 0) &#123;&#125; 不要写复合三元表达式.代码费解，eslint rules: no-nested-ternary. 12345678910111213141516// badconst foo = maybe1 &gt; maybe2 ? \"bar\" : value1 &gt; value2 ? \"baz\" : null;// betterconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;// bestconst maybeNull = value1 &gt; value2 ? 'baz' : null;const foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull; 去除不必要的三元表达式 ，eslint rules: no-unneeded-ternary. 123456789// badconst foo = a ? a : b;const bar = c ? true : false;const baz = c ? false : true;// goodconst foo = a || b;const bar = !!c;const baz = !c; 块 块代码都需要大括号 12345678910111213141516// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction foo() &#123; return false; &#125;// goodfunction bar() &#123; return false;&#125; else不要换行 . eslint: brace-style 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; 注释 Use /** ... */ for multi-line comments. 12345678910111213// bad// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123;&#125;// good/** * make() returns a new element * based on the passed-in tag name */function make(tag) &#123;&#125; 用//单行注释，在代码前 123456789101112131415161718// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125;// goodfunction getType() &#123; // set the default type to 'no type' const type = this._type || 'no type'; return type;&#125; 注释以空格开头. eslint: spaced-comment 1234567// bad//is current tabconst active = true;// good// is current tabconst active = true; 空格符 四个空格缩进. eslint: indent 123456789// badfunction bar() &#123;∙const name;&#125;// goodfunction baz() &#123;∙∙∙∙const name;&#125; 大括号等块级代码前面一个空格 eslint: space-before-blocks 12345678910111213141516// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year'&#125;);// gooddog.set('attr', &#123; age: '1 year'&#125;); if,while后面加空格，但是function不加 eslint: keyword-spacing 12345678910111213141516// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 赋值的=前后要有空格. eslint: space-infix-ops 12345// badconst x=y+5;// goodconst x = y + 5; 链式调用换行+缩进. eslint: newline-per-chained-call no-whitespace-before-property 12345678910// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount(); 块代码内部不要加空行. eslint: padded-blocks jscs: disallowPaddingNewlinesInBlocks 12345678910111213141516// badfunction bar() &#123; console.log(foo);&#125;// goodfunction bar() &#123; console.log(foo);&#125;// goodif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125; 每行代码不要超过100个字符 eslint: max-len 12345678910// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;// bad$.ajax(&#123; method: 'POST', url: 'https://airbnb.com/', data: &#123; name: 'John' &#125; &#125;).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));// goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar 命名规范 避免一个字符的变量 eslint: id-length 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 采用驼峰命名对象，函数. eslint: camelcase 12345678// badconst OBJEcttsssss = &#123;&#125;;const this_is_my_object = &#123;&#125;;function c() &#123;&#125;// goodconst thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 常量用大写字母加下划线 1DAY_IN_WEEK = 7 用大驼峰命名class eslint: new-cap 1234567891011 // bad function user(options) &#123; this.name = options.name; &#125; // good class User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125; 变量不要用-和_. eslint: no-underscore-dangle 显式类型转换 12345678910//badconst totalScore = this.reviewScore + &apos;&apos;;// goodconst totalScore = String(this.reviewScore);//bad inputValue=&apos;4&apos;const val = +inputValue;//goodconst val = Number(inputValue)//goodconst hasAge = !!age;","categories":[],"tags":[]},{"title":"test2t","slug":"test2t","date":"2017-03-08T02:26:28.000Z","updated":"2017-03-08T02:44:43.000Z","comments":true,"path":"2017/03/08/test2t/","link":"","permalink":"http://blook.me/2017/03/08/test2t/","excerpt":"","text":"images test 图片加载成功 sfsdsdf sdfsdfsdfdf","categories":[],"tags":[]},{"title":"categoriesdfs","slug":"categoriesdfs","date":"2017-03-07T11:10:55.000Z","updated":"2017-03-07T11:11:57.000Z","comments":true,"path":"2017/03/07/categoriesdfs/","link":"","permalink":"http://blook.me/2017/03/07/categoriesdfs/","excerpt":"","text":"","categories":[{"name":"前端","slug":"front","permalink":"http://blook.me/categories/front/"}],"tags":[{"name":"tttt","slug":"tttt","permalink":"http://blook.me/tags/tttt/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-02T10:10:53.000Z","updated":"2017-03-02T10:10:53.000Z","comments":true,"path":"2017/03/02/hello-world/","link":"","permalink":"http://blook.me/2017/03/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}